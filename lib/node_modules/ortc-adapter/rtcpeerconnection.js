"use strict";

var MediaSection = require("./mediasection");

var MediaStreamEvent = require("./mediastreamevent");

var RTCIceCandidate = require("./rtcicecandidate");

var RTCPeerConnectionIceEvent = require("./rtcpeerconnectioniceevent");

var RTCSessionDescription = require("./rtcsessiondescription");

var sdpTransform = require("sdp-transform");

var sdpUtils = require("./sdp-utils");

function RTCPeerConnection(configuration) {
    if (!(this instanceof RTCPeerConnection)) {
        return new RTCPeerConnection(configuration);
    }
    var gatherOptions = makeGatherOptions(configuration);
    var iceGatherer = new RTCIceGatherer(gatherOptions);
    var iceGatheringCompleted = false;
    iceGatherer.onlocalcandidate = this._onlocalcandidate.bind(this);
    var onicecandidate = null;
    var onicecandidateWasSet = false;
    var iceCandidatesAdded = 0;
    var iceTransport = new RTCIceTransport();
    var oniceconnectionstatechange = null;
    iceTransport.onicestatechange = this._onicestatechange.bind(this);
    var dtlsTransport = new RTCDtlsTransport(iceTransport);
    dtlsTransport.ondtlsstatechange = this._ondtlsstatechange.bind(this);
    var signalingState = "stable";
    var onsignalingstatechange = null;
    var localDescription = null;
    var remoteDescription = null;
    var onaddstream = null;
    Object.defineProperties(this, {
        _dtlsTransport: {
            value: dtlsTransport
        },
        _dtmfSenders: {
            value: new Map()
        },
        _gatherOptions: {
            value: gatherOptions
        },
        _iceCandidatesAdded: {
            get: function() {
                return iceCandidatesAdded;
            },
            set: function(_iceCandidatesAdded) {
                iceCandidatesAdded = _iceCandidatesAdded;
            }
        },
        _iceGatherer: {
            value: iceGatherer
        },
        _iceGatheringCompleted: {
            get: function() {
                return iceGatheringCompleted;
            },
            set: function(_iceGatheringCompleted) {
                iceGatheringCompleted = _iceGatheringCompleted;
            }
        },
        _iceTransport: {
            value: iceTransport
        },
        _localCandidates: {
            value: new Set()
        },
        _localDescription: {
            get: function() {
                return localDescription;
            },
            set: function(_localDescription) {
                localDescription = _localDescription;
            }
        },
        _localStreams: {
            value: new Set()
        },
        _midCounters: {
            value: {
                audio: 0,
                video: 0
            }
        },
        _remoteCandidates: {
            value: new Set()
        },
        _remoteDescription: {
            get: function() {
                return remoteDescription;
            },
            set: function(_remoteDescription) {
                remoteDescription = _remoteDescription;
            }
        },
        _remoteStreams: {
            value: []
        },
        _rtpReceivers: {
            value: new Map()
        },
        _rtpSenders: {
            value: new Map()
        },
        _signalingState: {
            get: function() {
                return signalingState;
            },
            set: function(_signalingState) {
                signalingState = _signalingState;
                if (this.onsignalingstatechange) {
                    this.onsignalingstatechange();
                }
            }
        },
        _streamIds: {
            value: new Map()
        },
        iceConnectionState: {
            enumerable: true,
            get: function() {
                return iceTransport.state;
            }
        },
        iceGatheringState: {
            enumerable: true,
            get: function() {
                if (iceGatheringCompleted) {
                    return "gathering";
                } else {
                    return "complete";
                }
            }
        },
        localDescription: {
            enumerable: true,
            get: function() {
                return localDescription;
            }
        },
        onaddstream: {
            enumerable: true,
            get: function() {
                return onaddstream;
            },
            set: function(_onaddstream) {
                onaddstream = _onaddstream;
            }
        },
        onicecandidate: {
            enumerable: true,
            get: function() {
                return onicecandidate;
            },
            set: function(_onicecandidate) {
                onicecandidate = _onicecandidate;
                if (!onicecandidateWasSet) {
                    try {
                        iceGatherer.getLocalCandidates().forEach(iceGatherer.onlocalcandidate);
                    } catch (error) {}
                }
                onicecandidateWasSet = true;
            }
        },
        oniceconnectionstatechange: {
            enumerable: true,
            get: function() {
                return oniceconnectionstatechange;
            },
            set: function(_oniceconnectionstatechange) {
                oniceconnectionstatechange = _oniceconnectionstatechange;
            }
        },
        onsignalingstatechange: {
            enumerable: true,
            get: function() {
                return onsignalingstatechange;
            },
            set: function(_onsignalingstatechange) {
                onsignalingstatechange = _onsignalingstatechange;
            }
        },
        remoteDescription: {
            enumerable: true,
            get: function() {
                return remoteDescription;
            }
        },
        signalingState: {
            enumerable: true,
            get: function() {
                return signalingState;
            }
        }
    });
}

RTCPeerConnection.prototype._makeMid = function _makeMid(kind) {
    return kind + ++this._midCounters[kind];
};

RTCPeerConnection.prototype._ondtlsstatechange = function _ondtlsstatechange(event) {
    void event;
};

RTCPeerConnection.prototype._onicestatechange = function _onicestatechange(event) {
    if (this.oniceconnectionstatechange) {
        this.oniceconnectionstatechange(event);
    }
};

RTCPeerConnection.prototype._onlocalcandidate = function _onlocalcandidate(event) {
    if (isEmptyObject(event.candidate)) {
        this._iceGatheringCompleted = true;
    }
    this._localCandidates.add(event.candidate);
    if (this.onicecandidate) {
        var webrtcCandidate = makeWebRTCCandidate(event.candidate);
        this.onicecandidate(makeOnIceCandidateEvent(webrtcCandidate));
    }
};

RTCPeerConnection.prototype._sendRtp = function _sendRtp(mediaSection) {
    var kind = mediaSection.kind;
    this._rtpSenders.forEach(function(rtpSender) {
        if (rtpSender.track.kind !== kind) {
            return;
        }
        rtpSender.send(mediaSection.capabilities);
    }, this);
    return this;
};

RTCPeerConnection.prototype._sendAndReceiveRtp = function _sendAndReceiveRtp(mediaSections) {
    mediaSections.forEach(function(mediaSection) {
        if (mediaSection.direction === "sendrecv" || mediaSection.direction === "sendonly") {
            this._sendRtp(mediaSection);
        }
        if (mediaSection.direction === "sendrecv" || mediaSection.direction === "recvonly") {
            this._receiveRtp(mediaSection);
        }
    }, this);
    return this;
};

RTCPeerConnection.prototype._receiveRtp = function _receiveRtp(mediaSection) {
    var kind = mediaSection.capabilities.type;
    var rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);
    rtpReceiver.receive(mediaSection.capabilities);
    var track = rtpReceiver.track;
    this._rtpReceivers.set(track, rtpReceiver);
    var mediaStream = new MediaStream();
    mediaStream.addTrack(track);
    this._remoteStreams.push(mediaStream);
    if (this.onaddstream) {
        this.onaddstream(makeOnAddStreamEvent(mediaStream));
    }
    return this;
};

RTCPeerConnection.prototype._startDtlsTransport = function _startDtlsTransport(dtlsParameters) {
    this._dtlsTransport.start(dtlsParameters);
    return this;
};

RTCPeerConnection.prototype._startIceTransport = function _startIceTransport(iceParameters) {
    var role = this.signalingState === "have-local-offer" ? "controlling" : "controlled";
    this._iceTransport.start(this._iceGatherer, iceParameters, role);
    return this;
};

RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate, onSuccess, onFailure) {
    if (!onSuccess) {
        return new Promise(this.addIceCandidate.bind(this, candidate));
    }
    void onFailure;
    this._iceCandidatesAdded++;
    var ortcCandidate = makeORTCCandidate(candidate);
    var triple = [ ortcCandidate.ip, ortcCandidate.port, ortcCandidate.transport ].join(" ");
    if (!this._remoteCandidates.has(triple)) {
        this._remoteCandidates.add(triple);
        this._iceTransport.addRemoteCandidate(ortcCandidate);
    }
    if (onSuccess) {
        onSuccess();
    }
};

RTCPeerConnection.prototype.addStream = function addStream(mediaStream) {
    this._localStreams.add(mediaStream);
    mediaStream.getTracks().forEach(function(track) {
        var rtpSender = new RTCRtpSender(track, this._dtlsTransport);
        this._rtpSenders.set(track, rtpSender);
        this._streamIds.set(track, mediaStream.id);
    }, this);
};

RTCPeerConnection.prototype.close = function close() {
    this._signalingState = "closed";
    this._rtpReceivers.forEach(function(rtpReceiver) {
        rtpReceiver.stop();
    });
    this._dtlsTransport.stop();
    this._iceTransport.stop();
};

RTCPeerConnection.prototype.createAnswer = function createAnswer(onSuccess, onFailure) {
    if (typeof onSuccess !== "function") {
        return new Promise(this.createAnswer.bind(this));
    }
    if (this.signalingState !== "have-remote-offer") {
        onFailure(invalidSignalingState(this.signalingState));
        return;
    }
    var remote = sdpUtils.parseDescription(this.remoteDescription);
    var streams = this.getLocalStreams();
    var tracks = {
            audio: [],
            video: []
        };
    streams.forEach(function(stream) {
        tracks.audio = tracks.audio.concat(stream.getAudioTracks());
        tracks.video = tracks.video.concat(stream.getVideoTracks());
    });
    var mediaSections = remote.mediaSections.map(function(remoteMediaSection) {
            var kind = remoteMediaSection.kind;
            var remoteDirection = remoteMediaSection.direction;
            var remoteCapabilities = remoteMediaSection.capabilities;
            var localCapabilities = RTCRtpSender.getCapabilities(kind);
            var sharedCodecs = intersectCodecs(remoteCapabilities.codecs, localCapabilities.codecs);
            var sharedCapabilities = {
                    codecs: sharedCodecs
                };
            var capabilities = sharedCapabilities;
            var direction;
            var track;
            if (!sharedCodecs.length) {
                return remoteMediaSection.copyAndReject();
            }
            if (remoteDirection === "inactive" || remoteDirection === "recvonly" && !tracks[kind].length) {
                direction = "inactive";
            } else if (remoteDirection === "recvonly") {
                track = tracks[kind].shift();
                direction = "sendonly";
            } else if (remoteDirection === "sendrecv") {
                track = tracks[kind].shift();
                direction = track ? "sendrecv" : "recvonly";
            } else {
                direction = "recvonly";
            }
            var streamId = this._streamIds.get(track);
            var mediaSection = remoteMediaSection.copy(null, null, capabilities, direction, null, streamId, track);
            return mediaSection;
        }, this);
    mediaSections.forEach(function(mediaSection) {
        this._localCandidates.forEach(mediaSection.addCandidate, mediaSection);
    }, this);
    var sdp = sdpUtils.makeInitialSDPBlob();
    sdpUtils.addMediaSectionsToSDPBlob(sdp, mediaSections);
    sdpUtils.addIceParametersToSDPBlob(sdp, this._iceGatherer.getLocalParameters());
    sdpUtils.addDtlsParametersToSDPBlob(sdp, this._dtlsTransport.getLocalParameters());
    var description = new RTCSessionDescription({
            sdp: sdpTransform.write(sdp),
            type: "answer"
        });
    onSuccess(description);
};

RTCPeerConnection.prototype.createDTMFSender = function createDTMFSender(track) {
    if (!this._dtmfSenders.has(track)) {
        var rtpSender = this._rtpSenders.get(track);
        var dtmfSender = new RTCDtmfSender(rtpSender);
        this._dtmfSenders.set(track, dtmfSender);
    }
    return this._dtmfSenders.get(track);
};

RTCPeerConnection.prototype.createOffer = function createOffer(onSuccess, onFailure, options) {
    if (typeof onSuccess !== "function") {
        return new Promise(function(resolve, reject) {
            this.createOffer(resolve, reject, onSuccess);
        }.bind(this));
    }
    var N = {
            audio: null,
            video: null
        };
    var M = {
            audio: 0,
            video: 0
        };
    options = options || {};
    [ "optional", "mandatory" ].forEach(function(optionType) {
        if (!(optionType in options)) {
            return;
        }
        if ("OfferToReceiveAudio" in options[optionType]) {
            N.audio = Number(options[optionType].OfferToReceiveAudio);
        }
        if ("OfferToReceiveVideo" in options[optionType]) {
            N.video = Number(options[optionType].OfferToReceiveVideo);
        }
    });
    var mediaSections = [];
    var _N = {
            audio: N.audio,
            video: N.video
        };
    var streams = this.getLocalStreams();
    streams.forEach(function(stream) {
        var audioTracks = stream.getAudioTracks();
        var videoTracks = stream.getVideoTracks();
        M.audio += audioTracks.length;
        M.video += videoTracks.length;
        var tracks = audioTracks.concat(videoTracks);
        tracks.forEach(function(track) {
            var kind = track.kind;
            var capabilities = RTCRtpSender.getCapabilities(kind);
            var direction;
            var mid = this._makeMid(kind);
            if (_N.audio === null) {
                direction = "sendrecv";
            } else if (!_N[kind]) {
                direction = "sendonly";
            } else {
                _N[kind]--;
                direction = "sendrecv";
            }
            var mediaSection = new MediaSection(null, null, capabilities, direction, kind, mid, null, null, stream.id, track);
            mediaSections.push(mediaSection);
        }, this);
    }, this);
    [ "audio", "video" ].forEach(function(kind) {
        var k = Math.max(N[kind] - M[kind], 0);
        if (!k) {
            return;
        }
        var capabilities = RTCRtpSender.getCapabilities(kind);
        var direction = "recvonly";
        var mid;
        var mediaSection;
        while (k--) {
            mid = this._makeMid(kind);
            mediaSection = new MediaSection(null, null, capabilities, direction, kind, mid);
            mediaSections.push(mediaSection);
        }
    }, this);
    mediaSections.forEach(function(mediaSection) {
        this._localCandidates.forEach(mediaSection.addCandidate, mediaSection);
    }, this);
    var sdp = sdpUtils.makeInitialSDPBlob();
    sdpUtils.addMediaSectionsToSDPBlob(sdp, mediaSections);
    sdpUtils.addIceParametersToSDPBlob(sdp, this._iceGatherer.getLocalParameters());
    sdpUtils.addDtlsParametersToSDPBlob(sdp, this._dtlsTransport.getLocalParameters());
    var description = new RTCSessionDescription({
            sdp: sdpTransform.write(sdp),
            type: "offer"
        });
    onSuccess(description);
};

RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    return Array.from(this._localStreams);
};

RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
    return this._remoteStreams.slice();
};

RTCPeerConnection.prototype.removeStream = function removeStream(mediaStream) {
    this._localStreams.delete(mediaStream);
    mediaStream.getTracks().forEach(function(track) {
        this._rtpSenders.get(track).stop();
        this._rtpSenders.delete(track);
        this._streamIds.delete(track);
    }, this);
};

RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription(description, onSuccess, onFailure) {
    if (!onSuccess) {
        return new Promise(this.setLocalDescription.bind(this, description));
    }
    var nextSignalingState;
    switch (this.signalingState) {
      case "stable":
        nextSignalingState = "have-local-offer";
        break;

      case "have-remote-offer":
        nextSignalingState = "stable";
        break;

      default:
        onFailure(invalidSignalingState(this.signalingState));
        return;
    }
    var parsed = sdpUtils.parseDescription(description);
    if (this.signalingState === "have-remote-offer") {
        parsed.mediaSections.forEach(this._sendRtp, this);
        var remote = sdpUtils.parseDescription(this.remoteDescription);
        var remoteSsrc = remote.mediaSections[0].capabilities.encodings[0].ssrc;
        parsed.mediaSections.forEach(function(mediaSection) {
            mediaSection.capabilities.encodings.forEach(function(encoding) {
                encoding.ssrc = remoteSsrc;
            });
            mediaSection.capabilities.rtcp.ssrc = remoteSsrc;
        });
        parsed.mediaSections.forEach(this._receiveRtp, this);
    }
    this._localDescription = description;
    this._signalingState = nextSignalingState;
    onSuccess();
};

RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(description, onSuccess, onFailure) {
    if (!onSuccess) {
        return new Promise(this.setRemoteDescription.bind(this, description));
    }
    var nextSignalingState;
    switch (this.signalingState) {
      case "stable":
        nextSignalingState = "have-remote-offer";
        break;

      case "have-local-offer":
        nextSignalingState = "stable";
        break;

      default:
        onFailure(invalidSignalingState(this.signalingState));
        return;
    }
    var parsed = sdpUtils.parseDescription(description);
    if (this._iceTransport.state !== "closed" && this._iceTransport.state !== "completed") {
        parsed.mediaSections.forEach(function(mediaSection) {
            mediaSection.candidates.forEach(this._iceTransport.addRemoteCandidate, this._iceTransport);
        }, this);
        this._startIceTransport(parsed.iceParameters[0]);
        this._startDtlsTransport(parsed.dtlsParameters[0]);
    }
    if (this.signalingState === "have-local-offer") {
        parsed.mediaSections.forEach(this._receiveRtp, this);
        parsed.mediaSections.forEach(this._sendRtp, this);
    }
    this._remoteDescription = description;
    this._signalingState = nextSignalingState;
    onSuccess();
};

function invalidSignalingState(signalingState) {
    return new Error("Invalid signaling state: " + signalingState);
}

function isEmptyObject(object) {
    return !Object.keys(object).length;
}

function makeGatherOptions(configuration) {
    return {
        gatherPolicy: configuration.gatherPolicy || "all",
        iceServers: []
    };
}

function makeOnAddStreamEvent(stream) {
    return new MediaStreamEvent("addstream", {
        stream: stream
    });
}

function makeOnIceCandidateEvent(candidate) {
    return new RTCPeerConnectionIceEvent("icecandidate", {
        candidate: candidate
    });
}

function makeORTCCandidate(candidate) {
    if (!candidate) {
        return {};
    }
    var start = candidate.candidate.indexOf("candidate:");
    var line = candidate.candidate.slice(start + 10).replace(/ +/g, " ").split(" ");
    var ortcIceCandidate = {
            foundation: line[0],
            protocol: line[2],
            priority: parseInt(line[3]),
            ip: line[4],
            port: parseInt(line[5]),
            type: line[7],
            relatedAddress: null,
            relatedPort: 0,
            tcpType: "active"
        };
    if (ortcIceCandidate.type !== "host") {
        ortcIceCandidate.relatedAddress = line[9];
        ortcIceCandidate.relatedPort = parseInt(line[11]);
    }
    return ortcIceCandidate;
}

function makeWebRTCCandidate(candidate) {
    if (isEmptyObject(candidate)) {
        return null;
    }
    var line = [ "a=candidate", candidate.foundation, 1, candidate.protocol, candidate.priority, candidate.ip, candidate.port, candidate.type ];
    if (candidate.relatedAddress) {
        line = line.concat([ "raddr", candidate.relatedAddress, "rport", candidate.relatedPort ]);
    }
    line.push("generation 0");
    return new RTCIceCandidate({
        candidate: line.join(" "),
        sdpMLineIndex: 0
    });
}

function intersectCodecs(localCodecs, remoteCodecs) {
    var sharedCodecs = [];
    localCodecs.forEach(function(localCodec) {
        remoteCodecs.forEach(function(remoteCodec) {
            if (localCodec.name === remoteCodec.name && localCodec.clockRate === remoteCodec.clockRate && localCodec.numChannels === remoteCodec.numChannels) {
                sharedCodecs.push(remoteCodec);
            }
        });
    });
    return sharedCodecs;
}

module.exports = RTCPeerConnection;