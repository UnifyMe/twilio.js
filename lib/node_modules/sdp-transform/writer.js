var grammar = require("./grammar");

var formatRegExp = /%[sdv%]/g;

var format = function(formatStr) {
        var i = 1;
        var args = arguments;
        var len = args.length;
        return formatStr.replace(formatRegExp, function(x) {
            if (i >= len) {
                return x;
            }
            var arg = args[i];
            i += 1;
            switch (x) {
              case "%%":
                return "%";

              case "%s":
                return String(arg);

              case "%d":
                return Number(arg);

              case "%v":
                return "";
            }
        });
    };

var makeLine = function(type, obj, location) {
        var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
        var args = [ type + "=" + str ];
        if (obj.names) {
            for (var i = 0; i < obj.names.length; i += 1) {
                var n = obj.names[i];
                if (obj.name) {
                    args.push(location[obj.name][n]);
                } else {
                    args.push(location[obj.names[i]]);
                }
            }
        } else {
            args.push(location[obj.name]);
        }
        return format.apply(null, args);
    };

var defaultOuterOrder = [ "v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a" ];

var defaultInnerOrder = [ "i", "c", "b", "a" ];

module.exports = function(session, opts) {
    opts = opts || {};
    if (session.version == null) {
        session.version = 0;
    }
    if (session.name == null) {
        session.name = " ";
    }
    session.media.forEach(function(mLine) {
        if (mLine.payloads == null) {
            mLine.payloads = "";
        }
    });
    var outerOrder = opts.outerOrder || defaultOuterOrder;
    var innerOrder = opts.innerOrder || defaultInnerOrder;
    var sdp = [];
    outerOrder.forEach(function(type) {
        grammar[type].forEach(function(obj) {
            if (obj.name in session && session[obj.name] != null) {
                sdp.push(makeLine(type, obj, session));
            } else if (obj.push in session && session[obj.push] != null) {
                session[obj.push].forEach(function(el) {
                    sdp.push(makeLine(type, obj, el));
                });
            }
        });
    });
    session.media.forEach(function(mLine) {
        sdp.push(makeLine("m", grammar.m[0], mLine));
        innerOrder.forEach(function(type) {
            grammar[type].forEach(function(obj) {
                if (obj.name in mLine && mLine[obj.name] != null) {
                    sdp.push(makeLine(type, obj, mLine));
                } else if (obj.push in mLine && mLine[obj.push] != null) {
                    mLine[obj.push].forEach(function(el) {
                        sdp.push(makeLine(type, obj, el));
                    });
                }
            });
        });
    });
    return sdp.join("\r\n") + "\r\n";
};